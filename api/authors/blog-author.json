{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"LeNet","uid":"139386a48ee9ff8eae54fecf132447a0","slug":"LeNet","date":"2023-02-20T10:33:27.000Z","updated":"2023-02-20T12:45:01.242Z","comments":true,"path":"api/articles/LeNet.json","keywords":null,"cover":[],"text":"LeNet Introduction 这是世界上最早发布的卷积神经网络之一，由AT&amp;T贝尔实验室的研究员Yann LeCun在1989年提出的（并以其命名） 目的是识别图像 MNIST 中的手写数字 当时，Yann LeCun发表了第一篇通过反向传播成功训练卷积神经网络的...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"最大公因数GCD","uid":"9d8d702581fafe91f0e84d17245c7b9e","slug":"最大公因数GCD","date":"2023-02-18T10:47:55.939Z","updated":"2022-01-12T11:25:28.992Z","comments":true,"path":"api/articles/最大公因数GCD.json","keywords":null,"cover":null,"text":"最大公因数GCD 原理 利用了欧几里得算法，即辗转相除法 核心等式——gcd(a,b) = gcd(b,a mod b) 证明 a可以表示成a = kb + r（a，b，k，r皆为正整数) 假设d是a,b的一个公约数，记作d|a,d|b) 即a和b都可以被d整除。 而r = a ...","link":"","photos":[],"count_time":{"symbolsCount":813,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"信息论","uid":"a0a717998dbf88c81be122d0bce3bca3","slug":"信息论","date":"2023-02-18T10:32:18.000Z","updated":"2023-02-18T10:44:30.881Z","comments":true,"path":"api/articles/信息论.json","keywords":null,"cover":null,"text":"Information Theory MLAPP 2.8 Preface 信息论(Information Theory)：应用数学的一个分支，涉及用紧凑的方法来表示数据（如数据压缩和编码），以及具有鲁棒性的储存和传输数据。在机器学习中，信息论常常应用于连续型变量 信息论的基本想法...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"卷积神经网络","uid":"665540b83d48c62e220c6e1d58a9965e","slug":"卷积神经网络","date":"2023-02-18T10:24:15.000Z","updated":"2023-02-20T11:22:17.315Z","comments":true,"path":"api/articles/卷积神经网络.json","keywords":null,"cover":[],"text":"卷积神经网络 卷积网络(convolutional network) 又称卷积神经网络(CNN)，是专门用来处理具有类似网格结构的数据的神经网络 通常指那些至少在网络的一层中使用卷积运算来代替一般的矩阵乘法运算的神经网络 卷积运算 卷积是对两个实变函数的一种数学运算 在许多实际问...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"贝叶斯统计","uid":"60fb8c126ebe52ae9e85a9be67ca6bb2","slug":"贝叶斯统计","date":"2023-02-18T10:23:28.000Z","updated":"2023-02-18T11:36:11.159Z","comments":true,"path":"api/articles/贝叶斯统计.json","keywords":null,"cover":null,"text":"贝叶斯统计 MLAPP 149 DL 85 5.1 Introduction 区别于频率派统计方法和基于估计单一值的方法：基于该估计做所有的预测 另一种方法是在做预测时就考虑所有可能的，后者属于贝叶斯统计(Bayesian statistics) 贝叶斯统计的核心在于：使用后验分...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"机器学习基础","uid":"e9525b7ef8e5ead70d9f4aba30aa5c7e","slug":"机器学习基础","date":"2023-02-18T08:33:33.000Z","updated":"2023-02-18T09:56:18.012Z","comments":true,"path":"api/articles/机器学习基础.json","keywords":null,"cover":null,"text":"机器学习基础 DL 1.学习算法 机器学习算法是一种能够从数据中学习的算法，可定义为 ”对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习是指，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升\" 1.1 任务T 学习的过程本身并不是任务，学习是所谓获取...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":5,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"二叉树","uid":"563a71603f1af2b0a426978adee1756b","slug":"二叉树","date":"2022-04-20T01:49:36.000Z","updated":"2023-02-18T11:09:03.548Z","comments":true,"path":"api/articles/二叉树.json","keywords":null,"cover":null,"text":"二叉树 树 定义 一棵树t是一个非空的有限元素的集合，其中一个元素为根（root），其余元素组成t的子树（subtree） 在层次数据中最高层的元素是根，其直接下一级元素是子树的根 树的画法 在画一棵树时，每一个元素都代表一个节点。树根画在最上方，其子树画在下面。在根和子树的根之...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"线性表","uid":"b96df039eaa03d2a5634c2cc83e5cad0","slug":"线性表","date":"2022-04-20T01:41:09.000Z","updated":"2022-04-20T01:41:09.782Z","comments":true,"path":"api/articles/线性表.json","keywords":null,"cover":null,"text":" ","link":"","photos":[],"count_time":{"symbolsCount":2,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"快速幂","uid":"9fc7aaa29955e8777b63cdc5e2f3c111","slug":"快速幂","date":"2022-02-14T03:22:15.000Z","updated":"2023-02-18T11:35:41.608Z","comments":true,"path":"api/articles/快速幂.json","keywords":null,"cover":null,"text":"快速幂 快速幂——OIWiki 在O(logn)的时间内计算 an 可以运用于模意义下取幂、矩阵幂等运算 算法描述 二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。 因为有个二进制位，因此当我们知道了后，我们只用计算O(logn)次乘法就可以计算出...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"二分匹配","uid":"4aa58050e03a812b4fa7990ab0778c08","slug":"二分匹配","date":"2022-01-17T08:44:06.000Z","updated":"2022-01-18T04:49:57.042Z","comments":true,"path":"api/articles/二分匹配.json","keywords":null,"cover":null,"text":"二分匹配 bool dfs(int x) &#123; for(int i=1;i&lt;=n;i++) &#123; if(mapp[x][i]&amp;&amp;(!used[i])) &#123; used[i]=1; if(linker[i]==-1||dfs(linke...","link":"","photos":[],"count_time":{"symbolsCount":555,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"图的存储","uid":"8fd51d91ee8f082030932013cc236c76","slug":"图的存储","date":"2022-01-16T08:23:46.000Z","updated":"2022-01-16T08:43:28.285Z","comments":true,"path":"api/articles/图的存储.json","keywords":null,"cover":null,"text":"图的存储 直接存边 使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点 struct edge&#123; int n,w; &#125; vector&lt;edge> e; vector&lt;bool> vis void dfs(int u) &#123; if ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"最短路","uid":"530e1936c4d6e837f2bf21a86f73c106","slug":"最短路","date":"2022-01-16T07:42:55.000Z","updated":"2022-01-17T07:53:02.872Z","comments":true,"path":"api/articles/最短路.json","keywords":null,"cover":null,"text":"最短路 性质 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边 对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过n，边数不会超过n-1 记号 n为图上点的数目，m为图上边的数目 s为最...","link":"","photos":[],"count_time":{"symbolsCount":226,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T09:56:49.745Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"text":"STL STL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"背包DP","uid":"4421686b118d9483ed6838244ba67f35","slug":"背包DP","date":"2022-01-15T07:21:57.000Z","updated":"2023-02-18T11:08:52.870Z","comments":true,"path":"api/articles/背包DP.json","keywords":null,"cover":null,"text":"背包DP 背包DP——OIWiki 0-1背包 已知条件有第个物品的重量，价值，以及背包的总容量,每个物体只有取和不取两种状态 设 DP 状态为在只能放前个物品的情况下，容量为的背包所能达到的最大总价值 状态转移方程 枚举时，从枚举到，保证总是在前被更新 for (int i =...","link":"","photos":[],"count_time":{"symbolsCount":984,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"动态规划","uid":"f6af5bf3fb5f66f52237908153c03aea","slug":"动态规划","date":"2022-01-15T01:55:19.000Z","updated":"2022-01-15T12:52:42.639Z","comments":true,"path":"api/articles/动态规划.json","keywords":null,"cover":null,"text":"动态规划DP 动态规划——OIWiki 思路 应用于子问题重叠的情况，即不同的子问题拥有公共的子问题 （子问题的求解是递归进行的，将其划分为更小的子子问题） 对于每个子子问题只求解一次，并将其保存在一个表格中。 #### 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，...","link":"","photos":[],"count_time":{"symbolsCount":327,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2022-01-13T07:25:39.000Z","updated":"2022-01-14T08:52:36.217Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":null,"text":"并查集 并查集——OIwiki 并查集——知乎 种类并查集——知乎 应用 并查集判环 ","link":"","photos":[],"count_time":{"symbolsCount":53,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"贪心算法","uid":"827701aa0aeba949971d70c354c78372","slug":"贪心算法","date":"2022-01-13T02:24:15.000Z","updated":"2022-04-20T01:55:07.726Z","comments":true,"path":"api/articles/贪心算法.json","keywords":null,"cover":null,"text":"贪心 基本思路 每一步行动总是采取最优解 适用范围 贪心算法在有最优子结构的问题中尤为有效。 最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解 证明方法 微扰(邻项交换)：证明再任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差。(常...","link":"","photos":[],"count_time":{"symbolsCount":694,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"最小公倍数LCM","uid":"f39f5057e79f1bc6b78f8eec0e6063d5","slug":"最小公倍数LCM","date":"2022-01-12T10:29:18.000Z","updated":"2022-01-12T12:05:21.966Z","comments":true,"path":"api/articles/最小公倍数LCM.json","keywords":null,"cover":null,"text":"最小公倍数LCM 原理 最大公约数法 最小公倍数 = 两整数的乘积 ➗ 最大公倍数 前置知识——最大公因数GCD ","link":"","photos":[],"count_time":{"symbolsCount":62,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":3,"tags":17,"word_count":"23k","post_count":18}