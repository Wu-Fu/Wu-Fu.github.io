[{"id":"e9525b7ef8e5ead70d9f4aba30aa5c7e","title":"机器学习基础","content":"机器学习基础DL\n1.学习算法机器学习算法是一种能够从数据中学习的算法，可定义为”对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习是指，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升”\n1.1 任务T学习的过程本身并不是任务，学习是所谓获取完成任务的能力的过程通常来讲，机器学习任务被定义为 机器学习系统应该如何处理 样本(example)样本是指我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的 特征(feature) 的集合\n1.2 性能度量P为评估机器学习算法的能力，设计其性能的定量度量是有必要的通常性能度量P是特定于任务T的，如分类型任务，性能度量P为准确率acc对性能度量P的衡量主要聚焦于未观测数据，即 测试集(test set) 上对于很多模型，选择一个与系统理想表现对应的性能度量通常是很有难度的\n1.3 经验E根据学习过程中的不同经验，机器学习算法可以大致分类为 无监督算法 和 有监督算法二者间主要区别来自于这样的一个视角：老师提供目标y给机器学习系统，指导其应该作什么。在无监督算法中则没有老师这样的角色，算法必须在没有指导的情况下理解数据\n2. 容量、过拟合和欠拟合机器学习的重要目的就是在观测到的数据，即 训练集 上的表现良好之外，也在测试集上表现良好这之中主要涉及一个算法的 泛化(generalization) 能力统计学习理论对泛化能力的提升给出了相应的方法：训练集和测试集数据通过数据集上被称为 数据生成过程(data generating process) 的概率分布生成。而在这一过程中采取 独立同分布(i.i.d assumption) 的假设，对提升泛化能力非常重要独立同分布指，每个数据集中的样本都是彼此相互独立的，并且训练集和测试集是同分布的这么做可以使得随机模型的训练误差期望和测试误差期望是一致的从中，我们可以延申出决定机器学习算法效果是否好的两个因素：\n\n降低训练误差\n缩小训练误差和测试误差的差距\n\n而这两个因素又分别对应着机器学习的两个主要挑战：欠拟合(underfitting) 和 过拟合(overfitting)欠拟合指模型不能在训练集上获得足够低的误差，过拟合指训练误差和测试误差之间的差距过大由此又另外延申出一个模型的概念：容量(capacity)容量指一个模型拟合各种函数的能力，容量过高则会使模型记住了不适于测试集的训练集性质从而表现为过拟合一种常见的控制容量的方法是选择 假设空间(hypothesis space) ，即学习算法的选择范围为解决方法的函数集主要控制容量的方法是：改变输入特征的数目和加入这些特征对应的参数而在这一过程中，应当遵循 奥卡姆剃刀原理对于容量任意高的极端情况，则归于 非参数模型 的概念非参数模型，指模型的参数会随着输入特征的变多而变多与参数模型相比，非参数模型更为灵活，所需要的假设更少，但一个严重的问题在于对于大部分数据而言计算困难\n2.1 没有免费午餐定理对于不同的问题，通常需要设计不同的模型，而学习理论也表明机器学习算法可以在有限个训练集样本中很好地泛化但是，必须强调，不存在万能的最佳模型，即 没有免费午餐定理(no free lunch theorem)这一理论表明，在所有可能的数据生成分布上平均之后，每一个分类算法在未事先观测的点上具有相同的错误率但必须强调，这一定理仅在考虑所有可能的数据生成分布时才成立在实际应用中，我们常对所遇到的概率分布进行假设，并针对该假设设计表现良好的算法\n2.2 正则化(TO DO) 正则化(regularization) 是指修改学习算法，使其降低泛化误差而非训练误差\n2.3 超参数和验证集 超参数(hyper-parameter) 常被设置用以控制算法的行为，超参数不是通过学习算法本身学习出来的常见的设置超参数的原因是该参数不适合在训练集上学习，如控制模型容量的所有超参数如果在训练集上训练这些超参数，这些超参数总是会区域最大可能的模型容量从而导致过拟合为解决这个问题，引出一个训练算法观测不到的 验证集(validation set) 样本验证集重要用于挑选模型的超参数验证集的重点在于测试样本不能以任何形式参与到模型的选择之中，包括设置超参数也是因此，之前提到的测试集中的样本不能用于验证集通常情况下，经常将用于学习参数的训练集中挑选子集来构建验证集，比例常见为4：1\n2.3.1 交叉验证在训练中，若训练集的误差很小，在数据集太小时，可能会带来一些问题一个小规模的测试集意味着平均测试误差估计的统计不确定性，使得很难判断算法A、B之间在给定任务上的优劣常见的一个解决方法为k-fold交叉验证算法如下：将训练集分为k个互斥子集，训练除第k个子集外的每一个子集，并在第k个子集上进行测试，以这种方式进行滚动式循环训练。之后，计算所有子集的平均误差，并以此来代替测试误差（tips：每个点只用于一次测试，和n-1次训练）\n2.4 估计、偏差和方差（TO DO）2.4.1 点估计2.4.2 偏差2.4.3 方差和标准差2.4.4 权衡偏差和方差以最小化均分误差2.4.5 一致性2.5 最大似然估计MLAPP 217估计统计模型参数$\\theta$的一种常见方法是计算其最大似然估计(Maximum likelihood estimation，MLE)对$\\theta$的最大似然估计定义为：$$\\begin{aligned}\\theta_{ML}&amp;=\\arg \\max_\\theta p_{model}(X;\\theta)\\&amp;=\\arg \\max_\\theta \\prod_{i=1}^{m} p_{model}(x^{(i)};\\theta)\\end{aligned}$$为简便运算，常将原函数进行取对数处理在实际进行代码运行时，我们更经常等价地采取最小化负对数的似然一种解释最大似然估计的观点是将它看作最小化训练集上的经验分布和数据之间的差异，二者间的差异程度由KL散度度量$$KL(p||q)=E_{x\\sim \\hat p_{data}}[log\\ \\hat p_{data}(x)-log\\ p_{data}(x)]$$其中左边一项仅涉及数据生成过程，因此只需要最小化$-E_{x\\sim \\hat p_{data}}[log\\ p_{data}(x)]$\n2.5.1 条件对数似然和均方误差（to do）由之前最大似然估计的定义，可进一步拓展到估计条件概率$P(y|x;\\theta)$从而给定x预测y而这就构成了大多数监督学习的基础\n2.5.2 最大似然的性质最大似然估计的最重要的一点在于，它被证明了当样本数目$m\\rightarrow \\infty$时，就收敛率而言是最好的渐进估计在以下条件下，最大似然估计具有一致性\n\n真实分布$p_{data}$必须在模型族$p_{model}(\\cdot ;\\theta)$中，否则，没有估计科研还原$p_{data}$\n真实分布$p_{data}$必须刚好对应一个$\\theta$值，否则，最大似然估计恢复除真实分布$p_{data}$后，也不能决定数据生成过程使用哪个$\\theta$除了最大似然估计之外，还有其他的归纳准则，且都具有一致性但这些一致估计的 统计效率(statistic efficiency) 可能区别很大在综合考虑了一致性和统计效率之后，最大似然通常是机器学习中的首选估计方法2.6 贝叶斯统计2.7 监督学习算法2.8 无监督学习算法2.9 随机梯度下降\n\n","slug":"机器学习基础","date":"2023-02-18T08:33:33.000Z","categories_index":"","tags_index":"AI","author_index":"碔砆"},{"id":"48433a70b7e09e957d48f01fa1012852","title":"STL","content":"STLSTL——OIWiki\n共同点\n声明形式： 容器名&lt;数据类型&gt; 变量名\n\n迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。\n  用法：容器名&lt;数据类型&gt;::iterator（可用auto代替）\n\n共有函数\n  = 赋值运算符以及复制构造函数\n  begin() 返回指向开头元素的迭代器\n  end() 返回指向末尾的下一个元素的迭代器。\n  size() 返回容器的元素个数\n  max_size() 返回容器理论上能储存最大的元素个数\n  empty() 返回元素是否为空\n  swap() 交换两个容器\n  clear() 清空容器\n  比较运算符 按字典序比较两个元素的大小\n\n\n序列式容器vectorstd::vector 是STL提供的内存连续的，可变长度的数组。\n能提供线性复杂度的插入和删除，以及常数复杂度的随机访问\n优点\n可以动态分配内存\n重写了比较运算符和赋值运算符\n初始化简单，可以&#123; &#125;或者=\n\n初始化操作vector&lt;数据类型&gt; 变量名(初始空间，初始值)\n创建拷贝 vector&lt;数据类型&gt; 变量名(被拷贝的变量名)\n移动整个容器 vector&lt;数据类型&gt; 变量名(std::move(原容器))\n成员函数 at(pos),operator[pos] 返回下标为pos的元素\n front() 返回首元素的引用\n back() 返回末尾元素的引用\n data() 返回数组第一个元素的指针\n resize() 改变vector的长度，多退少补\n reserve() 使得vector预留一定内存空间，避免不必要的内存拷贝\n insert() 支持在某个迭代器位置插入元素，线性复杂度\n erase() 删除某个迭代其或者区间的元素，返回最后被删除的迭代器\n push_back() 在末尾插入一个元素\n pop_back() 删除末尾元素\narray std::array是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装\n成员函数at(pos),operator[pos] 返回下标为pos的元素\n front() 返回首元素的引用\n back() 返回末尾元素的引用\n data() 返回数组第一个元素的指针\n fill(指定值) 以指定值填充容器\ndequestd::deque是STL提供的双端队列数据结构\n成员函数同vector\npush_front() 在头部插入一个元素\npop_front() 删除头部元素\nliststd::list 是STL提供的一个双向链表数据结构\n成员函数同deque\n关联式容器setset是关联容器，含有键值类型对象的已排序集\n内部通常采用红黑树实现\n插入与删除操作insert(x) 当容器中没有等价元素的时候，将元素 x 插入到 set 中。\nerase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。\nerase(pos) 删除迭代器为 pos 的元素，要求迭代器必须合法。\nerase(first,last) 删除迭代器在$[First,last)$范围内的所有元素。\n迭代器begin() 返回指向首元素的迭代器，其中 *begin = front\nend() 返回指向数组尾端占位符的迭代器，注意是没有元素的。\nrbegin() 返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。\nrend() 返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。\n查找操作count(x) 返回键值为x的元素数量\nfind(x) 存在键值为x的元素时会返回该元素的迭代器\nlower_bound(x) 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 end()\nupper_bound(x) 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回end()\nmapmap是有序键值对容器，它的元素的键是唯一的。map通常实现为红黑树\n搜索、移除和插入操作拥有对数复杂度\nmap&lt;Key,T&gt; mp\n操作查询操作同set\n操作与删除操作同set\n可以直接通过下标访问来进行查询或插入操作。例如mp[&quot;Alan&quot;]=100\n通过向 map 中插入一个类型为pair&lt;Key, T&gt;的值可以达到插入元素的目的，例如mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100))\n容器适配器栈std::stack是一种FILO的容器适配器\n操作top() 访问栈顶元素\npop() 删除栈顶元素\npush(x) 向栈顶插入x元素\nempty() 询问容器是否为空\nsize() 查询容器中的元素数量\n队列std::queue是一种FIFO的容器适配器\n操作同stack\nfront() 访问队首元素\n优先队列std::priority_queue\n操作同queue\n其他非STL容器bitsetstringpairstd::pair 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。\n操作初始化\n可以在定义时直接完成pair的初始化\n也可以使用先定义，后赋值的方法完成pair的初始化\n还可以使用std::make_pair函数。\n该函数接受两个变量，并返回由这两个变量组成的pair\n一种常用的方法是使用宏定义#define mp make_pair，将有些冗长的make_pair化简为mp\nmake_pair可以配合auto使用，以避免显式声明数据类型\n访问\n通过成员函数first与second,可以访问pair中包含的两个变量\n比较\n&lt;、&gt;、&lt;=、&gt;= 四个运算符会先比较两个pair中的第一个变量，在第一个变量相等的情况下再比较第二个变量\n算法部分next_permutation通常用于生成序列的全排列title: STLdate: 2022-01-15 20:53:20tags: 算法categories: 算法\n\nSTLSTL——OIWiki\n共同点\n声明形式： 容器名&lt;数据类型&gt; 变量名\n\n迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。\n  用法：容器名&lt;数据类型&gt;::iterator（可用auto代替）\n\n共有函数\n  = 赋值运算符以及复制构造函数\n  begin() 返回指向开头元素的迭代器\n  end() 返回指向末尾的下一个元素的迭代器。\n  size() 返回容器的元素个数\n  max_size() 返回容器理论上能储存最大的元素个数\n  empty() 返回元素是否为空\n  swap() 交换两个容器\n  clear() 清空容器\n  比较运算符 按字典序比较两个元素的大小\n\n\n序列式容器vectorstd::vector 是STL提供的内存连续的，可变长度的数组。\n能提供线性复杂度的插入和删除，以及常数复杂度的随机访问\n优点\n可以动态分配内存\n重写了比较运算符和赋值运算符\n初始化简单，可以&#123; &#125;或者=\n\n初始化操作vector&lt;数据类型&gt; 变量名(初始空间，初始值)\n创建拷贝 vector&lt;数据类型&gt; 变量名(被拷贝的变量名)\n移动整个容器 vector&lt;数据类型&gt; 变量名(std::move(原容器))\n成员函数 at(pos),operator[pos] 返回下标为pos的元素\n front() 返回首元素的引用\n back() 返回末尾元素的引用\n data() 返回数组第一个元素的指针\n resize() 改变vector的长度，多退少补\n reserve() 使得vector预留一定内存空间，避免不必要的内存拷贝\n insert() 支持在某个迭代器位置插入元素，线性复杂度\n erase() 删除某个迭代其或者区间的元素，返回最后被删除的迭代器\n push_back() 在末尾插入一个元素\n pop_back() 删除末尾元素\narray std::array是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装\n成员函数at(pos),operator[pos] 返回下标为pos的元素\n front() 返回首元素的引用\n back() 返回末尾元素的引用\n data() 返回数组第一个元素的指针\n fill(指定值) 以指定值填充容器\ndequestd::deque是STL提供的双端队列数据结构\n成员函数同vector\npush_front() 在头部插入一个元素\npop_front() 删除头部元素\nliststd::list 是STL提供的一个双向链表数据结构\n成员函数同deque\n关联式容器setset是关联容器，含有键值类型对象的已排序集\n内部通常采用红黑树实现\n插入与删除操作insert(x) 当容器中没有等价元素的时候，将元素 x 插入到 set 中。\nerase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。\nerase(pos) 删除迭代器为 pos 的元素，要求迭代器必须合法。\nerase(first,last) 删除迭代器在$[First,last)$范围内的所有元素。\n迭代器begin() 返回指向首元素的迭代器，其中 *begin = front\nend() 返回指向数组尾端占位符的迭代器，注意是没有元素的。\nrbegin() 返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。\nrend() 返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。\n查找操作count(x) 返回键值为x的元素数量\nfind(x) 存在键值为x的元素时会返回该元素的迭代器\nlower_bound(x) 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 end()\nupper_bound(x) 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回end()\nmapmap是有序键值对容器，它的元素的键是唯一的。map通常实现为红黑树\n搜索、移除和插入操作拥有对数复杂度\nmap&lt;Key,T&gt; mp\n操作查询操作同set\n操作与删除操作同set\n可以直接通过下标访问来进行查询或插入操作。例如mp[&quot;Alan&quot;]=100\n通过向 map 中插入一个类型为pair&lt;Key, T&gt;的值可以达到插入元素的目的，例如mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100))\n容器适配器栈std::stack是一种FILO的容器适配器\n操作top() 访问栈顶元素\npop() 删除栈顶元素\npush(x) 向栈顶插入x元素\nempty() 询问容器是否为空\nsize() 查询容器中的元素数量\n队列std::queue是一种FIFO的容器适配器\n操作同stack\nfront() 访问队首元素\n优先队列std::priority_queue\n操作同queue\n其他非STL容器bitsetstringpairstd::pair 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。\n操作初始化\n可以在定义时直接完成pair的初始化\n也可以使用先定义，后赋值的方法完成pair的初始化\n还可以使用std::make_pair函数。\n该函数接受两个变量，并返回由这两个变量组成的pair\n一种常用的方法是使用宏定义#define mp make_pair，将有些冗长的make_pair化简为mp\nmake_pair可以配合auto使用，以避免显式声明数据类型\n访问\n通过成员函数first与second,可以访问pair中包含的两个变量\n比较\n&lt;、&gt;、&lt;=、&gt;= 四个运算符会先比较两个pair中的第一个变量，在第一个变量相等的情况下再比较第二个变量\n算法部分next_permutation通常用于生成序列的全排列\n","slug":"STL","date":"2022-01-15T12:53:20.000Z","categories_index":"算法","tags_index":"算法","author_index":"碔砆"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集并查集——OIwiki\n并查集——知乎\n种类并查集——知乎\n应用\n并查集判环\n\n","slug":"并查集","date":"2022-01-13T07:25:39.000Z","categories_index":"算法","tags_index":"算法","author_index":"碔砆"}]