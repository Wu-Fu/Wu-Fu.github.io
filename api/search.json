[{"id":"e9525b7ef8e5ead70d9f4aba30aa5c7e","title":"机器学习基础","content":"机器学习基础\r\nDL\r\n1.学习算法\r\n机器学习算法是一种能够从数据中学习的算法，可定义为\r\n”对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习是指，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升\"\r\n1.1 任务T\r\n学习的过程本身并不是任务，学习是所谓获取完成任务的能力的过程\r\n通常来讲，机器学习任务被定义为 机器学习系统应该如何处理\r\n样本(example)\r\n样本是指我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的\r\n特征(feature) 的集合\r\n1.2 性能度量P\r\n为评估机器学习算法的能力，设计其性能的定量度量是有必要的\r\n通常性能度量P是特定于任务T的，如分类型任务，性能度量P为准确率acc\r\n对性能度量P的衡量主要聚焦于未观测数据，即 测试集(test\r\nset) 上\r\n对于很多模型，选择一个与系统理想表现对应的性能度量通常是很有难度的\r\n1.3 经验E\r\n根据学习过程中的不同经验，机器学习算法可以大致分类为\r\n无监督算法 和 有监督算法\r\n二者间主要区别来自于这样的一个视角：老师提供目标y给机器学习系统，指导其应该作什么。在无监督算法中则没有老师这样的角色，算法必须在没有指导的情况下理解数据\r\n2. 容量、过拟合和欠拟合\r\n机器学习的重要目的就是在观测到的数据，即 训练集\r\n上的表现良好之外，也在测试集上表现良好\r\n这之中主要涉及一个算法的 泛化(generalization)\r\n能力\r\n统计学习理论对泛化能力的提升给出了相应的方法：\r\n训练集和测试集数据通过数据集上被称为 数据生成过程(data\r\ngenerating process) 的概率分布生成。而在这一过程中采取\r\n独立同分布(i.i.d assumption)\r\n的假设，对提升泛化能力非常重要\r\n独立同分布指，每个数据集中的样本都是彼此相互独立的，并且训练集和测试集是同分布的\r\n这么做可以使得随机模型的训练误差期望和测试误差期望是一致的\r\n从中，我们可以延申出决定机器学习算法效果是否好的两个因素：\r\n\r\n降低训练误差\r\n缩小训练误差和测试误差的差距\r\n\r\n而这两个因素又分别对应着机器学习的两个主要挑战：欠拟合(underfitting)\r\n和 过拟合(overfitting)\r\n欠拟合指模型不能在训练集上获得足够低的误差，过拟合指训练误差和测试误差之间的差距过大\r\n由此又另外延申出一个模型的概念：容量(capacity)\r\n容量指一个模型拟合各种函数的能力，容量过高则会使模型记住了不适于测试集的训练集性质从而表现为过拟合\r\n一种常见的控制容量的方法是选择 假设空间(hypothesis\r\nspace) ，即学习算法的选择范围为解决方法的函数集\r\n主要控制容量的方法是：改变输入特征的数目和加入这些特征对应的参数\r\n而在这一过程中，应当遵循 奥卡姆剃刀原理\r\n对于容量任意高的极端情况，则归于 非参数模型\r\n的概念\r\n非参数模型，指模型的参数会随着输入特征的变多而变多\r\n与参数模型相比，非参数模型更为灵活，所需要的假设更少，但一个严重的问题在于对于大部分数据而言计算困难\r\n2.1 没有免费午餐定理\r\n对于不同的问题，通常需要设计不同的模型，而学习理论也表明机器学习算法可以在有限个训练集样本中很好地泛化\r\n但是，必须强调，不存在万能的最佳模型，即 没有免费午餐定理(no\r\nfree lunch theorem)\r\n这一理论表明，在所有可能的数据生成分布上平均之后，每一个分类算法在未事先观测的点上具有相同的错误率\r\n但必须强调，这一定理仅在考虑所有可能的数据生成分布时才成立\r\n在实际应用中，我们常对所遇到的概率分布进行假设，并针对该假设设计表现良好的算法\r\n2.2 正则化(TO DO)\r\n正则化(regularization)\r\n是指修改学习算法，使其降低泛化误差而非训练误差\r\n2.3 超参数和验证集\r\n超参数(hyper-parameter)\r\n常被设置用以控制算法的行为，超参数不是通过学习算法本身学习出来的\r\n常见的设置超参数的原因是该参数不适合在训练集上学习，如控制模型容量的所有超参数\r\n如果在训练集上训练这些超参数，这些超参数总是会区域最大可能的模型容量从而导致过拟合\r\n为解决这个问题，引出一个训练算法观测不到的 验证集(validation\r\nset) 样本\r\n验证集重要用于挑选模型的超参数\r\n验证集的重点在于测试样本不能以任何形式参与到模型的选择之中，包括设置超参数\r\n也是因此，之前提到的测试集中的样本不能用于验证集\r\n通常情况下，经常将用于学习参数的训练集中挑选子集来构建验证集，比例常见为4：1\r\n2.3.1 交叉验证\r\n在训练中，若训练集的误差很小，在数据集太小时，可能会带来一些问题\r\n一个小规模的测试集意味着平均测试误差估计的统计不确定性，使得很难判断算法A、B之间在给定任务上的优劣\r\n常见的一个解决方法为k-fold交叉验证\r\n算法如下：将训练集分为k个互斥子集，训练除第k个子集外的每一个子集，并在第k个子集上进行测试，以这种方式进行滚动式循环训练。之后，计算所有子集的平均误差，并以此来代替测试误差\r\n（tips：每个点只用于一次测试，和n-1次训练）\r\n2.4 估计、偏差和方差（TO DO）\r\n2.4.1 点估计\r\n2.4.2 偏差\r\n2.4.3 方差和标准差\r\n2.4.4\r\n权衡偏差和方差以最小化均分误差\r\n2.4.5 一致性\r\n2.5 最大似然估计\r\nMLAPP 217 估计统计模型参数的一种常见方法是计算其最大似然估计(Maximum\r\nlikelihood estimation，MLE) 对的最大似然估计定义为：\r\n\r\n为简便运算，常将原函数进行取对数处理\r\n在实际进行代码运行时，我们更经常等价地采取最小化负对数的似然\r\n一种解释最大似然估计的观点是将它看作最小化训练集上的经验分布和数据之间的差异，二者间的差异程度由KL散度度量\r\n\r\n其中左边一项仅涉及数据生成过程，因此只需要最小化\r\n2.5.1 条件对数似然和均方误差（to\r\ndo）\r\n由之前最大似然估计的定义，可进一步拓展到估计条件概率从而给定x预测y\r\n而这就构成了大多数监督学习的基础\r\n2.5.2 最大似然的性质\r\n最大似然估计的最重要的一点在于，它被证明了当样本数目时，就收敛率而言是最好的渐进估计\r\n在以下条件下，最大似然估计具有一致性\r\n\r\n真实分布必须在模型族中，否则，没有估计可以还原\r\n真实分布必须刚好对应一个值，否则，最大似然估计恢复除真实分布后，也不能决定数据生成过程使用哪个\r\n\r\n除了最大似然估计之外，还有其他的归纳准则，且都具有一致性\r\n但这些一致估计的 统计效率(statistic efficiency)\r\n可能区别很大\r\n在综合考虑了一致性和统计效率之后，最大似然通常是机器学习中的首选估计方法\r\n2.6 贝叶斯统计\r\n2.7 监督学习算法\r\n2.8 无监督学习算法\r\n2.9 随机梯度下降\r\n","slug":"机器学习基础","date":"2023-02-18T08:33:33.000Z","categories_index":"AI学习","tags_index":"AI学习","author_index":"碔砆"},{"id":"48433a70b7e09e957d48f01fa1012852","title":"STL","content":"STL\r\nSTL——OIWiki\r\n## 共同点\r\n\r\n声明形式： 容器名&lt;数据类型&gt; 变量名\r\n迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。\r\n用法：容器名&lt;数据类型&gt;::iterator（可用auto代替）\r\n共有函数\r\n= 赋值运算符以及复制构造函数\r\nbegin() 返回指向开头元素的迭代器\r\nend()\r\n返回指向末尾的下一个元素的迭代器。\r\nsize() 返回容器的元素个数\r\nmax_size() 返回容器理论上能储存最大的元素个数\r\nempty() 返回元素是否为空\r\nswap() 交换两个容器\r\nclear() 清空容器\r\n比较运算符 按字典序比较两个元素的大小\r\n\r\n序列式容器\r\nvector\r\nstd::vector 是STL提供的内存连续的，可变长度的数组。\r\n能提供线性复杂度的插入和删除，以及常数复杂度的随机访问\r\n优点\r\n\r\n可以动态分配内存\r\n重写了比较运算符和赋值运算符\r\n初始化简单，可以&#123; &#125;或者=\r\n\r\n初始化操作\r\nvector&lt;数据类型&gt; 变量名(初始空间，初始值)\r\n创建拷贝\r\nvector&lt;数据类型&gt; 变量名(被拷贝的变量名)\r\n移动整个容器\r\nvector&lt;数据类型&gt; 变量名(std::move(原容器))\r\n成员函数\r\nat(pos),operator[pos] 返回下标为pos的元素\r\nfront() 返回首元素的引用\r\nback() 返回末尾元素的引用\r\ndata() 返回数组第一个元素的指针\r\nresize() 改变vector的长度，多退少补\r\nreserve()\r\n使得vector预留一定内存空间，避免不必要的内存拷贝\r\ninsert() 支持在某个迭代器位置插入元素，线性复杂度\r\nerase()\r\n删除某个迭代其或者区间的元素，返回最后被删除的迭代器\r\npush_back() 在末尾插入一个元素\r\npop_back() 删除末尾元素\r\n### array\r\nstd::array是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装\r\n#### 成员函数\r\nat(pos),operator[pos] 返回下标为pos的元素\r\nfront() 返回首元素的引用\r\nback() 返回末尾元素的引用\r\ndata() 返回数组第一个元素的指针\r\nfill(指定值) 以指定值填充容器\r\ndeque\r\nstd::deque是STL提供的双端队列数据结构\r\n成员函数\r\n同vector\r\npush_front() 在头部插入一个元素\r\npop_front() 删除头部元素\r\nlist\r\nstd::list 是STL提供的一个双向链表数据结构\r\n成员函数\r\n同deque\r\n关联式容器\r\nset\r\nset是关联容器，含有键值类型对象的已排序集\r\n内部通常采用红黑树实现\r\n插入与删除操作\r\ninsert(x) 当容器中没有等价元素的时候，将元素 x 插入到\r\nset 中。\r\nerase(x) 删除值为 x 的 所有\r\n元素，返回删除元素的个数。\r\nerase(pos) 删除迭代器为 pos\r\n的元素，要求迭代器必须合法。\r\nerase(first,last) 删除迭代器在\\([First,last)\\)范围内的所有元素。\r\n迭代器\r\nbegin() 返回指向首元素的迭代器，其中\r\n*begin = front\r\nend()\r\n返回指向数组尾端占位符的迭代器，注意是没有元素的。\r\nrbegin()\r\n返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。\r\nrend()\r\n返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。\r\n查找操作\r\ncount(x) 返回键值为x的元素数量\r\nfind(x) 存在键值为x的元素时会返回该元素的迭代器\r\nlower_bound(x)\r\n返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回\r\nend()\r\nupper_bound(x)\r\n返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回end()\r\nmap\r\nmap是有序键值对容器，它的元素的键是唯一的。map通常实现为红黑树\r\n搜索、移除和插入操作拥有对数复杂度\r\nmap&lt;Key,T&gt; mp #### 操作\r\n查询操作同set\r\n操作与删除操作同set\r\n可以直接通过下标访问来进行查询或插入操作。例如\r\nmp[\"Alan\"]=100\r\n通过向 map\r\n中插入一个类型为pair&lt;Key, T&gt;的值可以达到插入元素的目的，例如mp.insert(pair&lt;string,int&gt;(\"Alan\",100))\r\n容器适配器\r\n栈\r\nstd::stack是一种FILO的容器适配器\r\n操作\r\ntop() 访问栈顶元素\r\npop() 删除栈顶元素\r\npush(x) 向栈顶插入x元素\r\nempty() 询问容器是否为空\r\nsize() 查询容器中的元素数量\r\n队列\r\nstd::queue是一种FIFO的容器适配器\r\n操作\r\n同stack\r\nfront() 访问队首元素\r\n优先队列\r\nstd::priority_queue\r\n操作\r\n同queue\r\n其他非STL容器\r\nbitset\r\nstring\r\npair\r\nstd::pair\r\n是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。\r\n操作\r\n初始化\r\n可以在定义时直接完成pair的初始化\r\n也可以使用先定义，后赋值的方法完成pair的初始化\r\n还可以使用std::make_pair函数。\r\n该函数接受两个变量，并返回由这两个变量组成的pair\r\n一种常用的方法是使用宏定义#define mp make_pair，将有些冗长的make_pair化简为mp\r\nmake_pair可以配合auto使用，以避免显式声明数据类型\r\n访问\r\n通过成员函数first与second,可以访问pair中包含的两个变量\r\n比较\r\n&lt;、&gt;、&lt;=、&gt;=\r\n四个运算符会先比较两个pair中的第一个变量，在第一个变量相等的情况下再比较第二个变量\r\n算法部分\r\nnext_permutation\r\n通常用于生成序列的全排列 title: STL date: 2022-01-15 20:53:20 tags:\r\n算法 categories: 算法 ---\r\nSTL\r\nSTL——OIWiki\r\n## 共同点\r\n\r\n声明形式： 容器名&lt;数据类型&gt; 变量名\r\n迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。\r\n用法：容器名&lt;数据类型&gt;::iterator（可用auto代替）\r\n共有函数\r\n= 赋值运算符以及复制构造函数\r\nbegin() 返回指向开头元素的迭代器\r\nend()\r\n返回指向末尾的下一个元素的迭代器。\r\nsize() 返回容器的元素个数\r\nmax_size() 返回容器理论上能储存最大的元素个数\r\nempty() 返回元素是否为空\r\nswap() 交换两个容器\r\nclear() 清空容器\r\n比较运算符 按字典序比较两个元素的大小\r\n\r\n序列式容器\r\nvector\r\nstd::vector 是STL提供的内存连续的，可变长度的数组。\r\n能提供线性复杂度的插入和删除，以及常数复杂度的随机访问\r\n优点\r\n\r\n可以动态分配内存\r\n重写了比较运算符和赋值运算符\r\n初始化简单，可以&#123; &#125;或者=\r\n\r\n初始化操作\r\nvector&lt;数据类型&gt; 变量名(初始空间，初始值)\r\n创建拷贝\r\nvector&lt;数据类型&gt; 变量名(被拷贝的变量名)\r\n移动整个容器\r\nvector&lt;数据类型&gt; 变量名(std::move(原容器))\r\n成员函数\r\nat(pos),operator[pos] 返回下标为pos的元素\r\nfront() 返回首元素的引用\r\nback() 返回末尾元素的引用\r\ndata() 返回数组第一个元素的指针\r\nresize() 改变vector的长度，多退少补\r\nreserve()\r\n使得vector预留一定内存空间，避免不必要的内存拷贝\r\ninsert() 支持在某个迭代器位置插入元素，线性复杂度\r\nerase()\r\n删除某个迭代其或者区间的元素，返回最后被删除的迭代器\r\npush_back() 在末尾插入一个元素\r\npop_back() 删除末尾元素\r\n### array\r\nstd::array是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装\r\n#### 成员函数\r\nat(pos),operator[pos] 返回下标为pos的元素\r\nfront() 返回首元素的引用\r\nback() 返回末尾元素的引用\r\ndata() 返回数组第一个元素的指针\r\nfill(指定值) 以指定值填充容器\r\ndeque\r\nstd::deque是STL提供的双端队列数据结构\r\n成员函数\r\n同vector\r\npush_front() 在头部插入一个元素\r\npop_front() 删除头部元素\r\nlist\r\nstd::list 是STL提供的一个双向链表数据结构\r\n成员函数\r\n同deque\r\n关联式容器\r\nset\r\nset是关联容器，含有键值类型对象的已排序集\r\n内部通常采用红黑树实现\r\n插入与删除操作\r\ninsert(x) 当容器中没有等价元素的时候，将元素 x 插入到\r\nset 中。\r\nerase(x) 删除值为 x 的 所有\r\n元素，返回删除元素的个数。\r\nerase(pos) 删除迭代器为 pos\r\n的元素，要求迭代器必须合法。\r\nerase(first,last) 删除迭代器在\\([First,last)\\)范围内的所有元素。\r\n迭代器\r\nbegin() 返回指向首元素的迭代器，其中\r\n*begin = front\r\nend()\r\n返回指向数组尾端占位符的迭代器，注意是没有元素的。\r\nrbegin()\r\n返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。\r\nrend()\r\n返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。\r\n查找操作\r\ncount(x) 返回键值为x的元素数量\r\nfind(x) 存在键值为x的元素时会返回该元素的迭代器\r\nlower_bound(x)\r\n返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回\r\nend()\r\nupper_bound(x)\r\n返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回end()\r\nmap\r\nmap是有序键值对容器，它的元素的键是唯一的。map通常实现为红黑树\r\n搜索、移除和插入操作拥有对数复杂度\r\nmap&lt;Key,T&gt; mp #### 操作\r\n查询操作同set\r\n操作与删除操作同set\r\n可以直接通过下标访问来进行查询或插入操作。例如\r\nmp[\"Alan\"]=100\r\n通过向 map\r\n中插入一个类型为pair&lt;Key, T&gt;的值可以达到插入元素的目的，例如mp.insert(pair&lt;string,int&gt;(\"Alan\",100))\r\n容器适配器\r\n栈\r\nstd::stack是一种FILO的容器适配器\r\n操作\r\ntop() 访问栈顶元素\r\npop() 删除栈顶元素\r\npush(x) 向栈顶插入x元素\r\nempty() 询问容器是否为空\r\nsize() 查询容器中的元素数量\r\n队列\r\nstd::queue是一种FIFO的容器适配器\r\n操作\r\n同stack\r\nfront() 访问队首元素\r\n优先队列\r\nstd::priority_queue\r\n操作\r\n同queue\r\n其他非STL容器\r\nbitset\r\nstring\r\npair\r\nstd::pair\r\n是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。\r\n操作\r\n初始化\r\n可以在定义时直接完成pair的初始化\r\n也可以使用先定义，后赋值的方法完成pair的初始化\r\n还可以使用std::make_pair函数。\r\n该函数接受两个变量，并返回由这两个变量组成的pair\r\n一种常用的方法是使用宏定义#define mp make_pair，将有些冗长的make_pair化简为mp\r\nmake_pair可以配合auto使用，以避免显式声明数据类型\r\n访问\r\n通过成员函数first与second,可以访问pair中包含的两个变量\r\n比较\r\n&lt;、&gt;、&lt;=、&gt;=\r\n四个运算符会先比较两个pair中的第一个变量，在第一个变量相等的情况下再比较第二个变量\r\n算法部分\r\nnext_permutation\r\n通常用于生成序列的全排列\r\n","slug":"STL","date":"2022-01-15T12:53:20.000Z","categories_index":"算法","tags_index":"算法","author_index":"碔砆"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集\r\n并查集——OIwiki\r\n并查集——知乎\r\n种类并查集——知乎\r\n应用\r\n\r\n并查集判环\r\n\r\n","slug":"并查集","date":"2022-01-13T07:25:39.000Z","categories_index":"算法","tags_index":"算法","author_index":"碔砆"}]