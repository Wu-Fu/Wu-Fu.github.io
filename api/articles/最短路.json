{"title":"最短路","uid":"530e1936c4d6e837f2bf21a86f73c106","slug":"最短路","date":"2022-01-16T07:42:55.000Z","updated":"2022-01-17T07:53:02.872Z","comments":true,"path":"api/articles/最短路.json","keywords":null,"cover":null,"content":"<h1 id=\"最短路\">最短路</h1>\r\n<p>性质</p>\r\n<p>对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点</p>\r\n<p>对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边</p>\r\n<p>对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过n，边数不会超过n-1</p>\r\n<p>记号</p>\r\n<p>n为图上点的数目，m为图上边的数目</p>\r\n<p>s为最短路的源点</p>\r\n<p>D(u)为s点到u点的<em>实际</em>最短路长度</p>\r\n<p>dis(u)为s点到u点的<em>估计</em>最短路长度</p>\r\n<p>w(u,v)为(u,v)这一条边的边权</p>\r\n<h2 id=\"floyd算法\">Floyd算法</h2>\r\n","text":"最短路 性质 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边 对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过n，边数不会超过n-1 记号 n为图上点的数目，m为图上边的数目 s为最...","link":"","photos":[],"count_time":{"symbolsCount":226,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF\"><span class=\"toc-text\">最短路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#floyd%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Floyd算法</span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"图的存储","uid":"8fd51d91ee8f082030932013cc236c76","slug":"图的存储","date":"2022-01-16T08:23:46.000Z","updated":"2022-01-16T08:43:28.285Z","comments":true,"path":"api/articles/图的存储.json","keywords":null,"cover":null,"text":"图的存储 直接存边 使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点 struct edge&#123; int n,w; &#125; vector&lt;edge> e; vector&lt;bool> vis void dfs(int u) &#123; if ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T09:56:49.745Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"text":"STL STL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}