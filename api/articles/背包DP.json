{"title":"背包DP","uid":"4421686b118d9483ed6838244ba67f35","slug":"背包DP","date":"2022-01-15T07:21:57.000Z","updated":"2022-01-16T06:50:45.673Z","comments":true,"path":"api/articles/背包DP.json","keywords":null,"cover":null,"content":"<h1 id=\"背包dp\">背包DP</h1>\r\n<p><a href=\"https://oi-wiki.org/dp/knapsack/\">背包DP——OIWiki</a></p>\r\n<h2 id=\"背包\">0-1背包</h2>\r\n<p>已知条件有第<span class=\"math inline\">\\(i\\)</span>个物品的重量<span\r\nclass=\"math inline\">\\(w_i\\)</span>，价值<span\r\nclass=\"math inline\">\\(v_i\\)</span>，以及背包的总容量<span\r\nclass=\"math inline\">\\(W\\)</span>,每个物体只有取和不取两种状态</p>\r\n<p>设 DP 状态<span\r\nclass=\"math inline\">\\(f_{i,j}\\)</span>为在只能放前<span\r\nclass=\"math inline\">\\(i\\)</span>个物品的情况下，容量为<span\r\nclass=\"math inline\">\\(j\\)</span>的背包所能达到的最大总价值</p>\r\n<p><strong>状态转移方程</strong></p>\r\n<p><span class=\"math display\">\\[f_j=max(f_j,f_{j-w_i}+v_i)\\]</span></p>\r\n<p><strong>枚举时，从<span class=\"math inline\">\\(W\\)</span>枚举到<span\r\nclass=\"math inline\">\\(w_i\\)</span>，保证<span\r\nclass=\"math inline\">\\(f_{i,j}\\)</span>总是在<span\r\nclass=\"math inline\">\\(f_{i,j-w_i}\\)</span>前被更新</strong></p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> W<span class=\"token punctuation\">;</span> l <span class=\"token operator\">>=</span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> l<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>  \n        f<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>l <span class=\"token operator\">-</span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> v<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\r\n<p>多种价值时开多维数组即可</p>\r\n<p>枚举时也多开一层循环 ## 完全背包 完全背包模型与 0-1 背包类似，与 0-1\r\n背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次</p>\r\n<p><strong>状态转移方程</strong></p>\r\n<p><span class=\"math display\">\\[f_j=max(f_j,f_{j-w_i}+v_i)\\]</span></p>\r\n<p><strong>枚举时，从<span class=\"math inline\">\\(w_i\\)</span>枚举到<span\r\nclass=\"math inline\">\\(W\\)</span></strong></p>\r\n<ul>\r\n<li>tips: 注意f[0]的初始化，保证f[0]=0</li>\r\n</ul>\r\n<h2 id=\"多重背包\">多重背包</h2>\r\n<p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有<span\r\nclass=\"math inline\">\\(k_i\\)</span>个，而非一个</p>\r\n<p>朴素想法：将每种物品的<span\r\nclass=\"math inline\">\\(k_i\\)</span>个，视为不同种物品</p>\r\n<h3 id=\"二进制分组优化\">二进制分组优化</h3>\r\n<p>用<span\r\nclass=\"math inline\">\\(A_{i,j}\\)</span>代表第i种物品拆分出的第j个物品</p>\r\n<p>朴素法中存在问题:重复考虑了「同时选<span\r\nclass=\"math inline\">\\(A_{i,1},A_{i,2}\\)</span>」与「同时选<span\r\nclass=\"math inline\">\\(A_{i,2},A_{i,3}\\)</span>」这两个完全等效的情况</p>\r\n<p>通过<strong>二进制分组</strong>的方式使拆分方式更加优美</p>\r\n<p>具体地说就是令<span\r\nclass=\"math inline\">\\(A_{i,j}(j\\in[0,log_2(k_i+1)-1])\\)</span>分别表示由<span\r\nclass=\"math inline\">\\(2^j\\)</span>个单个物品「捆绑」而成的大物品。特殊地，若<span\r\nclass=\"math inline\">\\(k_i+1\\)</span>不是2的整数次幂，则需要在最后添加一个由<span\r\nclass=\"math inline\">\\(k_i-2^{[log_2(k_i+1)]-1}\\)</span>个单个物品「捆绑」而成的大物品用于补足</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//c表示2进制</span>\n    cin <span class=\"token operator\">>></span> p <span class=\"token operator\">>></span> h <span class=\"token operator\">>></span> k<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//p价值，h体积，k数量</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">-</span> c <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        k <span class=\"token operator\">-=</span> c<span class=\"token punctuation\">;</span>\n        list<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>w <span class=\"token operator\">=</span> c <span class=\"token operator\">*</span> p<span class=\"token punctuation\">;</span>\n        list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>v <span class=\"token operator\">=</span> c <span class=\"token operator\">*</span> h<span class=\"token punctuation\">;</span>\n        c <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  list<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>w <span class=\"token operator\">=</span> p <span class=\"token operator\">*</span> k<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//补足</span>\n  list<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>v <span class=\"token operator\">=</span> h <span class=\"token operator\">*</span> k<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\r\n<h2 id=\"混合背包\">混合背包</h2>\r\n<p>将以上3种背包结合，分开求解即可</p>\r\n<h2 id=\"section\"></h2>\r\n","text":"背包DP 背包DP——OIWiki 0-1背包 已知条件有第\\(i\\)个物品的重量\\(w_i\\)，价值\\(v_i\\)，以及背包的总容量\\(W\\),每个物体只有取和不取两种状态 设 DP 状态\\(f_{i,j}\\)为在只能放前\\(i\\)个物品的情况下，容量为\\(j\\)的背包所能达到...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85dp\"><span class=\"toc-text\">背包DP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">0-1背包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">多重背包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">二进制分组优化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">混合背包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#section\"><span class=\"toc-text\"></span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T09:56:49.745Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"text":"STL STL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"动态规划","uid":"f6af5bf3fb5f66f52237908153c03aea","slug":"动态规划","date":"2022-01-15T01:55:19.000Z","updated":"2022-01-15T12:52:42.639Z","comments":true,"path":"api/articles/动态规划.json","keywords":null,"cover":null,"text":"动态规划DP 动态规划——OIWiki 思路 应用于子问题重叠的情况，即不同的子问题拥有公共的子问题 （子问题的求解是递归进行的，将其划分为更小的子子问题） 对于每个子子问题只求解一次，并将其保存在一个表格中。 #### 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，...","link":"","photos":[],"count_time":{"symbolsCount":327,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}