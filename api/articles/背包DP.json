{"title":"背包DP","uid":"4421686b118d9483ed6838244ba67f35","slug":"背包DP","date":"2022-01-15T07:21:57.000Z","updated":"2022-01-16T06:50:45.673Z","comments":true,"path":"api/articles/背包DP.json","keywords":null,"cover":null,"content":"<h1 id=\"背包dp\">背包DP</h1>\r\n<p><a href=\"https://oi-wiki.org/dp/knapsack/\">背包DP——OIWiki</a></p>\r\n<h2 id=\"背包\">0-1背包</h2>\r\n<p>已知条件有第<span class=\"math inline\">\\(i\\)</span>个物品的重量<span\r\nclass=\"math inline\">\\(w_i\\)</span>，价值<span\r\nclass=\"math inline\">\\(v_i\\)</span>，以及背包的总容量<span\r\nclass=\"math inline\">\\(W\\)</span>,每个物体只有取和不取两种状态</p>\r\n<p>设 DP 状态<span\r\nclass=\"math inline\">\\(f_{i,j}\\)</span>为在只能放前<span\r\nclass=\"math inline\">\\(i\\)</span>个物品的情况下，容量为<span\r\nclass=\"math inline\">\\(j\\)</span>的背包所能达到的最大总价值</p>\r\n<p><strong>状态转移方程</strong></p>\r\n<p><span class=\"math display\">\\[f_j=max(f_j,f_{j-w_i}+v_i)\\]</span></p>\r\n<p><strong>枚举时，从<span class=\"math inline\">\\(W\\)</span>枚举到<span\r\nclass=\"math inline\">\\(w_i\\)</span>，保证<span\r\nclass=\"math inline\">\\(f_{i,j}\\)</span>总是在<span\r\nclass=\"math inline\">\\(f_{i,j-w_i}\\)</span>前被更新</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> l = W; l &gt;= w[i]; l--)  </span><br><span class=\"line\">        f[l]=<span class=\"built_in\">max</span>(f[l], f[l - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>\r\n<p>多种价值时开多维数组即可</p>\r\n<p>枚举时也多开一层循环 ## 完全背包 完全背包模型与 0-1 背包类似，与 0-1\r\n背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次</p>\r\n<p><strong>状态转移方程</strong></p>\r\n<p><span class=\"math display\">\\[f_j=max(f_j,f_{j-w_i}+v_i)\\]</span></p>\r\n<p><strong>枚举时，从<span class=\"math inline\">\\(w_i\\)</span>枚举到<span\r\nclass=\"math inline\">\\(W\\)</span></strong></p>\r\n<ul>\r\n<li>tips: 注意f[0]的初始化，保证f[0]=0</li>\r\n</ul>\r\n<h2 id=\"多重背包\">多重背包</h2>\r\n<p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有<span\r\nclass=\"math inline\">\\(k_i\\)</span>个，而非一个</p>\r\n<p>朴素想法：将每种物品的<span\r\nclass=\"math inline\">\\(k_i\\)</span>个，视为不同种物品</p>\r\n<h3 id=\"二进制分组优化\">二进制分组优化</h3>\r\n<p>用<span\r\nclass=\"math inline\">\\(A_{i,j}\\)</span>代表第i种物品拆分出的第j个物品</p>\r\n<p>朴素法中存在问题:重复考虑了「同时选<span\r\nclass=\"math inline\">\\(A_{i,1},A_{i,2}\\)</span>」与「同时选<span\r\nclass=\"math inline\">\\(A_{i,2},A_{i,3}\\)</span>」这两个完全等效的情况</p>\r\n<p>通过<strong>二进制分组</strong>的方式使拆分方式更加优美</p>\r\n<p>具体地说就是令<span\r\nclass=\"math inline\">\\(A_{i,j}(j\\in[0,log_2(k_i+1)-1])\\)</span>分别表示由<span\r\nclass=\"math inline\">\\(2^j\\)</span>个单个物品「捆绑」而成的大物品。特殊地，若<span\r\nclass=\"math inline\">\\(k_i+1\\)</span>不是2的整数次幂，则需要在最后添加一个由<span\r\nclass=\"math inline\">\\(k_i-2^{[log_2(k_i+1)]-1}\\)</span>个单个物品「捆绑」而成的大物品用于补足</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> c = <span class=\"number\">1</span>, p, h, k;     <span class=\"comment\">//c表示2进制</span></span><br><span class=\"line\">    cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;     <span class=\"comment\">//p价值，h体积，k数量</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k - c &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        k -= c;</span><br><span class=\"line\">        list[++index].w = c * p;</span><br><span class=\"line\">        list[index].v = c * h;</span><br><span class=\"line\">        c *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  list[++index].w = p * k;  <span class=\"comment\">//补足</span></span><br><span class=\"line\">  list[index].v = h * k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"混合背包\">混合背包</h2>\r\n<p>将以上3种背包结合，分开求解即可</p>\r\n<h2 id=\"section\"></h2>\r\n","text":"背包DP 背包DP——OIWiki 0-1背包 已知条件有第\\(i\\)个物品的重量\\(w_i\\)，价值\\(v_i\\)，以及背包的总容量\\(W\\),每个物体只有取和不取两种状态 设 DP 状态\\(f_{i,j}\\)为在只能放前\\(i\\)个物品的情况下，容量为\\(j\\)的背包所能达到...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85dp\"><span class=\"toc-text\">背包DP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">0-1背包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">多重背包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">二进制分组优化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">混合背包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#section\"><span class=\"toc-text\"></span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T09:56:49.745Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"text":"STL STL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"动态规划","uid":"f6af5bf3fb5f66f52237908153c03aea","slug":"动态规划","date":"2022-01-15T01:55:19.000Z","updated":"2022-01-15T12:52:42.639Z","comments":true,"path":"api/articles/动态规划.json","keywords":null,"cover":null,"text":"动态规划DP 动态规划——OIWiki 思路 应用于子问题重叠的情况，即不同的子问题拥有公共的子问题 （子问题的求解是递归进行的，将其划分为更小的子子问题） 对于每个子子问题只求解一次，并将其保存在一个表格中。 #### 最优子结构性质 问题的最优解由相关子问题的最优解组合而成，...","link":"","photos":[],"count_time":{"symbolsCount":327,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}