{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T07:58:18.522Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"content":"<h1 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h1><p><a href=\"https://oi-wiki.org/lang/csl/sequence-container/\">STL——OIWiki</a></p>\n<h2 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li><p>声明形式： <code>容器名&lt;数据类型&gt; 变量名</code></p>\n</li>\n<li><p>迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p>\n<p>  用法：<code>容器名&lt;数据类型&gt;::iterator</code>（可用<code>auto</code>代替）</p>\n</li>\n<li><p>共有函数</p>\n<p>  <code>=</code> 赋值运算符以及复制构造函数</p>\n<p>  <code>begin()</code> 返回指向开头元素的迭代器</p>\n<p>  <code>end()</code> 返回指向<strong>末尾的下一个元素</strong>的迭代器。</p>\n<p>  <code>size()</code> 返回容器的元素个数</p>\n<p>  <code>max_size()</code> 返回容器理论上能储存最大的元素个数</p>\n<p>  <code>empty()</code> 返回元素是否为空</p>\n<p>  <code>swap()</code> 交换两个容器</p>\n<p>  <code>clear()</code> 清空容器</p>\n<p>  <code>比较运算符</code> 按字典序比较两个元素的大小</p>\n</li>\n</ul>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><code>std::vector</code> 是STL提供的内存连续的，可变长度的数组。</p>\n<p>能提供线性复杂度的插入和删除，以及常数复杂度的随机访问</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>可以动态分配内存</li>\n<li>重写了比较运算符和赋值运算符</li>\n<li>初始化简单，可以<code>&#123; &#125;</code>或者<code>=</code></li>\n</ul>\n<h4 id=\"初始化操作\"><a href=\"#初始化操作\" class=\"headerlink\" title=\"初始化操作\"></a>初始化操作</h4><p><code>vector&lt;数据类型&gt; 变量名(初始空间，初始值)</code></p>\n<p>创建拷贝 <code>vector&lt;数据类型&gt; 变量名(被拷贝的变量名)</code></p>\n<p>移动整个容器 <code>vector&lt;数据类型&gt; 变量名(std::move(原容器))</code></p>\n<h4 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p> <code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\n<p> <code>front()</code> 返回首元素的引用</p>\n<p> <code>back()</code> 返回末尾元素的引用</p>\n<p> <code>data()</code> 返回数组第一个元素的指针</p>\n<p> <code>resize()</code> 改变<code>vector</code>的长度，多退少补</p>\n<p> <code>reserve()</code> 使得<code>vector</code>预留一定内存空间，避免不必要的内存拷贝</p>\n<p> <code>insert()</code> 支持在某个迭代器位置插入元素，线性复杂度</p>\n<p> <code>erase()</code> 删除某个迭代其或者区间的元素，返回最后被删除的迭代器</p>\n<p> <code>push_back()</code> 在末尾插入一个元素</p>\n<p> <code>pop_back()</code> 删除末尾元素</p>\n<h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><p> <code>std::array</code>是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装</p>\n<h4 id=\"成员函数-1\"><a href=\"#成员函数-1\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p><code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\n<p> <code>front()</code> 返回首元素的引用</p>\n<p> <code>back()</code> 返回末尾元素的引用</p>\n<p> <code>data()</code> 返回数组第一个元素的指针</p>\n<p> <code>fill(指定值)</code> 以指定值填充容器</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p><code>std::deque</code>是STL提供的双端队列数据结构</p>\n<h4 id=\"成员函数-2\"><a href=\"#成员函数-2\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p>同vector</p>\n<p><code>push_front()</code> 在头部插入一个元素</p>\n<p><code>pop_front()</code> 删除头部元素</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p><code>std::list</code> 是STL提供的一个双向链表数据结构</p>\n<h4 id=\"成员函数-3\"><a href=\"#成员函数-3\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p>同deque</p>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code>是关联容器，含有键值类型对象的已排序集</p>\n<p>内部通常采用红黑树实现</p>\n<h4 id=\"插入与删除操作\"><a href=\"#插入与删除操作\" class=\"headerlink\" title=\"插入与删除操作\"></a>插入与删除操作</h4><p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 set 中。</p>\n<p><code>erase(x)</code> 删除值为 x 的 所有 元素，返回删除元素的个数。</p>\n<p><code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</p>\n<p><code>erase(first,last)</code> 删除迭代器在$[First,last)$范围内的所有元素。</p>\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p><code>begin()</code> 返回指向首元素的迭代器，其中 <code>*begin = front</code></p>\n<p><code>end()</code> 返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n<p><code>rbegin()</code> 返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。</p>\n<p><code>rend()</code> 返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。</p>\n<h4 id=\"查找操作\"><a href=\"#查找操作\" class=\"headerlink\" title=\"查找操作\"></a>查找操作</h4><p><code>count(x)</code> 返回键值为x的元素数量</p>\n<p><code>find(x)</code> 存在键值为x的元素时会返回该元素的迭代器</p>\n<p><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code></p>\n<p><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回<code>end()</code></p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code>是有序键值对容器，它的元素的键是唯一的。<code>map</code>通常实现为红黑树</p>\n<p>搜索、移除和插入操作拥有对数复杂度</p>\n<p>map&lt;Key,T&gt; mp</p>\n<h4 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>查询操作同<code>set</code></p>\n<p>操作与删除操作同<code>set</code></p>\n<p>可以直接通过下标访问来进行查询或插入操作。例如<br><code>mp[&quot;Alan&quot;]=100</code></p>\n<p>通过向 map 中插入一个类型为<code>pair&lt;Key, T&gt;</code>的值可以达到插入元素的目的，例如<code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100))</code></p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><code>std::stack</code>是一种FILO的容器适配器</p>\n<h4 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p><code>top()</code> 访问栈顶元素</p>\n<p><code>pop()</code> 删除栈顶元素</p>\n<p><code>push(x)</code> 向栈顶插入x元素</p>\n<p><code>empty()</code> 询问容器是否为空</p>\n<p><code>size()</code> 查询容器中的元素数量</p>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p><code>std::queue</code>是一种FIFO的容器适配器</p>\n<h4 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>同<code>stack</code></p>\n<p><code>front()</code> 访问队首元素</p>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><p><code>std::priority_queue</code></p>\n<h4 id=\"操作-3\"><a href=\"#操作-3\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>同<code>queue</code></p>\n<h2 id=\"其他非STL容器\"><a href=\"#其他非STL容器\" class=\"headerlink\" title=\"其他非STL容器\"></a>其他非STL容器</h2><h3 id=\"bitset\"><a href=\"#bitset\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h3><p><code>std::pair</code> 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。</p>\n<h4 id=\"操作-4\"><a href=\"#操作-4\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>初始化</p>\n<p>可以在定义时直接完成<code>pair</code>的初始化</p>\n<p>也可以使用先定义，后赋值的方法完成<code>pair</code>的初始化</p>\n<p>还可以使用<code>std::make_pair</code>函数。</p>\n<p>该函数接受两个变量，并返回由这两个变量组成的<code>pair</code></p>\n<p>一种常用的方法是使用宏定义<code>#define mp make_pair</code>，将有些冗长的<code>make_pair</code>化简为<code>mp</code></p>\n<p><code>make_pair</code>可以配合<code>auto</code>使用，以避免显式声明数据类型</p>\n<p>访问</p>\n<p>通过成员函数<code>first</code>与<code>second</code>,可以访问<code>pair</code>中包含的两个变量</p>\n<p>比较</p>\n<p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 四个运算符会先比较两个<code>pair</code>中的第一个变量，在第一个变量相等的情况下再比较第二个变量</p>\n<h1 id=\"算法部分\"><a href=\"#算法部分\" class=\"headerlink\" title=\"算法部分\"></a>算法部分</h1><h2 id=\"next-permutation\"><a href=\"#next-permutation\" class=\"headerlink\" title=\"next_permutation\"></a>next_permutation</h2><p>通常用于生成序列的全排列<br>title: STL<br>date: 2022-01-15 20:53:20<br>tags: 算法<br>categories: 算法</p>\n<hr>\n<h1 id=\"STL-1\"><a href=\"#STL-1\" class=\"headerlink\" title=\"STL\"></a>STL</h1><p><a href=\"https://oi-wiki.org/lang/csl/sequence-container/\">STL——OIWiki</a></p>\n<h2 id=\"共同点-1\"><a href=\"#共同点-1\" class=\"headerlink\" title=\"共同点\"></a>共同点</h2><ul>\n<li><p>声明形式： <code>容器名&lt;数据类型&gt; 变量名</code></p>\n</li>\n<li><p>迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p>\n<p>  用法：<code>容器名&lt;数据类型&gt;::iterator</code>（可用<code>auto</code>代替）</p>\n</li>\n<li><p>共有函数</p>\n<p>  <code>=</code> 赋值运算符以及复制构造函数</p>\n<p>  <code>begin()</code> 返回指向开头元素的迭代器</p>\n<p>  <code>end()</code> 返回指向<strong>末尾的下一个元素</strong>的迭代器。</p>\n<p>  <code>size()</code> 返回容器的元素个数</p>\n<p>  <code>max_size()</code> 返回容器理论上能储存最大的元素个数</p>\n<p>  <code>empty()</code> 返回元素是否为空</p>\n<p>  <code>swap()</code> 交换两个容器</p>\n<p>  <code>clear()</code> 清空容器</p>\n<p>  <code>比较运算符</code> 按字典序比较两个元素的大小</p>\n</li>\n</ul>\n<h2 id=\"序列式容器-1\"><a href=\"#序列式容器-1\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><h3 id=\"vector-1\"><a href=\"#vector-1\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p><code>std::vector</code> 是STL提供的内存连续的，可变长度的数组。</p>\n<p>能提供线性复杂度的插入和删除，以及常数复杂度的随机访问</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>可以动态分配内存</li>\n<li>重写了比较运算符和赋值运算符</li>\n<li>初始化简单，可以<code>&#123; &#125;</code>或者<code>=</code></li>\n</ul>\n<h4 id=\"初始化操作-1\"><a href=\"#初始化操作-1\" class=\"headerlink\" title=\"初始化操作\"></a>初始化操作</h4><p><code>vector&lt;数据类型&gt; 变量名(初始空间，初始值)</code></p>\n<p>创建拷贝 <code>vector&lt;数据类型&gt; 变量名(被拷贝的变量名)</code></p>\n<p>移动整个容器 <code>vector&lt;数据类型&gt; 变量名(std::move(原容器))</code></p>\n<h4 id=\"成员函数-4\"><a href=\"#成员函数-4\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p> <code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\n<p> <code>front()</code> 返回首元素的引用</p>\n<p> <code>back()</code> 返回末尾元素的引用</p>\n<p> <code>data()</code> 返回数组第一个元素的指针</p>\n<p> <code>resize()</code> 改变<code>vector</code>的长度，多退少补</p>\n<p> <code>reserve()</code> 使得<code>vector</code>预留一定内存空间，避免不必要的内存拷贝</p>\n<p> <code>insert()</code> 支持在某个迭代器位置插入元素，线性复杂度</p>\n<p> <code>erase()</code> 删除某个迭代其或者区间的元素，返回最后被删除的迭代器</p>\n<p> <code>push_back()</code> 在末尾插入一个元素</p>\n<p> <code>pop_back()</code> 删除末尾元素</p>\n<h3 id=\"array-1\"><a href=\"#array-1\" class=\"headerlink\" title=\"array\"></a>array</h3><p> <code>std::array</code>是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装</p>\n<h4 id=\"成员函数-5\"><a href=\"#成员函数-5\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p><code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\n<p> <code>front()</code> 返回首元素的引用</p>\n<p> <code>back()</code> 返回末尾元素的引用</p>\n<p> <code>data()</code> 返回数组第一个元素的指针</p>\n<p> <code>fill(指定值)</code> 以指定值填充容器</p>\n<h3 id=\"deque-1\"><a href=\"#deque-1\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p><code>std::deque</code>是STL提供的双端队列数据结构</p>\n<h4 id=\"成员函数-6\"><a href=\"#成员函数-6\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p>同vector</p>\n<p><code>push_front()</code> 在头部插入一个元素</p>\n<p><code>pop_front()</code> 删除头部元素</p>\n<h3 id=\"list-1\"><a href=\"#list-1\" class=\"headerlink\" title=\"list\"></a>list</h3><p><code>std::list</code> 是STL提供的一个双向链表数据结构</p>\n<h4 id=\"成员函数-7\"><a href=\"#成员函数-7\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h4><p>同deque</p>\n<h2 id=\"关联式容器-1\"><a href=\"#关联式容器-1\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><h3 id=\"set-1\"><a href=\"#set-1\" class=\"headerlink\" title=\"set\"></a>set</h3><p><code>set</code>是关联容器，含有键值类型对象的已排序集</p>\n<p>内部通常采用红黑树实现</p>\n<h4 id=\"插入与删除操作-1\"><a href=\"#插入与删除操作-1\" class=\"headerlink\" title=\"插入与删除操作\"></a>插入与删除操作</h4><p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 set 中。</p>\n<p><code>erase(x)</code> 删除值为 x 的 所有 元素，返回删除元素的个数。</p>\n<p><code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</p>\n<p><code>erase(first,last)</code> 删除迭代器在$[First,last)$范围内的所有元素。</p>\n<h4 id=\"迭代器-1\"><a href=\"#迭代器-1\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p><code>begin()</code> 返回指向首元素的迭代器，其中 <code>*begin = front</code></p>\n<p><code>end()</code> 返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\n<p><code>rbegin()</code> 返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。</p>\n<p><code>rend()</code> 返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。</p>\n<h4 id=\"查找操作-1\"><a href=\"#查找操作-1\" class=\"headerlink\" title=\"查找操作\"></a>查找操作</h4><p><code>count(x)</code> 返回键值为x的元素数量</p>\n<p><code>find(x)</code> 存在键值为x的元素时会返回该元素的迭代器</p>\n<p><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code></p>\n<p><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回<code>end()</code></p>\n<h3 id=\"map-1\"><a href=\"#map-1\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map</code>是有序键值对容器，它的元素的键是唯一的。<code>map</code>通常实现为红黑树</p>\n<p>搜索、移除和插入操作拥有对数复杂度</p>\n<p>map&lt;Key,T&gt; mp</p>\n<h4 id=\"操作-5\"><a href=\"#操作-5\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>查询操作同<code>set</code></p>\n<p>操作与删除操作同<code>set</code></p>\n<p>可以直接通过下标访问来进行查询或插入操作。例如<br><code>mp[&quot;Alan&quot;]=100</code></p>\n<p>通过向 map 中插入一个类型为<code>pair&lt;Key, T&gt;</code>的值可以达到插入元素的目的，例如<code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100))</code></p>\n<h2 id=\"容器适配器-1\"><a href=\"#容器适配器-1\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><h3 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><code>std::stack</code>是一种FILO的容器适配器</p>\n<h4 id=\"操作-6\"><a href=\"#操作-6\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p><code>top()</code> 访问栈顶元素</p>\n<p><code>pop()</code> 删除栈顶元素</p>\n<p><code>push(x)</code> 向栈顶插入x元素</p>\n<p><code>empty()</code> 询问容器是否为空</p>\n<p><code>size()</code> 查询容器中的元素数量</p>\n<h3 id=\"队列-1\"><a href=\"#队列-1\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p><code>std::queue</code>是一种FIFO的容器适配器</p>\n<h4 id=\"操作-7\"><a href=\"#操作-7\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>同<code>stack</code></p>\n<p><code>front()</code> 访问队首元素</p>\n<h3 id=\"优先队列-1\"><a href=\"#优先队列-1\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><p><code>std::priority_queue</code></p>\n<h4 id=\"操作-8\"><a href=\"#操作-8\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>同<code>queue</code></p>\n<h2 id=\"其他非STL容器-1\"><a href=\"#其他非STL容器-1\" class=\"headerlink\" title=\"其他非STL容器\"></a>其他非STL容器</h2><h3 id=\"bitset-1\"><a href=\"#bitset-1\" class=\"headerlink\" title=\"bitset\"></a>bitset</h3><h3 id=\"string-1\"><a href=\"#string-1\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"pair-1\"><a href=\"#pair-1\" class=\"headerlink\" title=\"pair\"></a>pair</h3><p><code>std::pair</code> 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。</p>\n<h4 id=\"操作-9\"><a href=\"#操作-9\" class=\"headerlink\" title=\"操作\"></a>操作</h4><p>初始化</p>\n<p>可以在定义时直接完成<code>pair</code>的初始化</p>\n<p>也可以使用先定义，后赋值的方法完成<code>pair</code>的初始化</p>\n<p>还可以使用<code>std::make_pair</code>函数。</p>\n<p>该函数接受两个变量，并返回由这两个变量组成的<code>pair</code></p>\n<p>一种常用的方法是使用宏定义<code>#define mp make_pair</code>，将有些冗长的<code>make_pair</code>化简为<code>mp</code></p>\n<p><code>make_pair</code>可以配合<code>auto</code>使用，以避免显式声明数据类型</p>\n<p>访问</p>\n<p>通过成员函数<code>first</code>与<code>second</code>,可以访问<code>pair</code>中包含的两个变量</p>\n<p>比较</p>\n<p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 四个运算符会先比较两个<code>pair</code>中的第一个变量，在第一个变量相等的情况下再比较第二个变量</p>\n<h1 id=\"算法部分-1\"><a href=\"#算法部分-1\" class=\"headerlink\" title=\"算法部分\"></a>算法部分</h1><h2 id=\"next-permutation-1\"><a href=\"#next-permutation-1\" class=\"headerlink\" title=\"next_permutation\"></a>next_permutation</h2><p>通常用于生成序列的全排列</p>\n","feature":true,"text":"STLSTL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数据...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#STL\"><span class=\"toc-text\">STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">共同点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">序列式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vector\"><span class=\"toc-text\">vector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">初始化操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#array\"><span class=\"toc-text\">array</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deque\"><span class=\"toc-text\">deque</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-3\"><span class=\"toc-text\">成员函数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">关联式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">插入与删除操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">查找操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">容器适配器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-2\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97\"><span class=\"toc-text\">优先队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-3\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%9D%9ESTL%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">其他非STL容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pair\"><span class=\"toc-text\">pair</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-4\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86\"><span class=\"toc-text\">算法部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#next-permutation\"><span class=\"toc-text\">next_permutation</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#STL-1\"><span class=\"toc-text\">STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9-1\"><span class=\"toc-text\">共同点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8-1\"><span class=\"toc-text\">序列式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vector-1\"><span class=\"toc-text\">vector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9-1\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">初始化操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-4\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#array-1\"><span class=\"toc-text\">array</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-5\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deque-1\"><span class=\"toc-text\">deque</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-6\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#list-1\"><span class=\"toc-text\">list</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-7\"><span class=\"toc-text\">成员函数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-1\"><span class=\"toc-text\">关联式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set-1\"><span class=\"toc-text\">set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">插入与删除操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8-1\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">查找操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map-1\"><span class=\"toc-text\">map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-5\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-1\"><span class=\"toc-text\">容器适配器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88-1\"><span class=\"toc-text\">栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-6\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97-1\"><span class=\"toc-text\">队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-7\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-1\"><span class=\"toc-text\">优先队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-8\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%9D%9ESTL%E5%AE%B9%E5%99%A8-1\"><span class=\"toc-text\">其他非STL容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bitset-1\"><span class=\"toc-text\">bitset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string-1\"><span class=\"toc-text\">string</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pair-1\"><span class=\"toc-text\">pair</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-9\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86-1\"><span class=\"toc-text\">算法部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#next-permutation-1\"><span class=\"toc-text\">next_permutation</span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2023-02-18T06:46:21.822Z","updated":"2023-02-18T06:45:07.895Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":430,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}