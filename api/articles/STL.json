{"title":"STL","uid":"48433a70b7e09e957d48f01fa1012852","slug":"STL","date":"2022-01-15T12:53:20.000Z","updated":"2023-02-18T09:56:49.745Z","comments":true,"path":"api/articles/STL.json","keywords":null,"cover":null,"content":"<h1 id=\"stl\">STL</h1>\r\n<p><a\r\nhref=\"https://oi-wiki.org/lang/csl/sequence-container/\">STL——OIWiki</a></p>\r\n<h2 id=\"共同点\">共同点</h2>\r\n<ul>\r\n<li><p>声明形式： <code>容器名&lt;数据类型&gt; 变量名</code></p></li>\r\n<li><p>迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p>\r\n<p>用法：<code>容器名&lt;数据类型&gt;::iterator</code>（可用<code>auto</code>代替）</p></li>\r\n<li><p>共有函数</p>\r\n<p><code>=</code> 赋值运算符以及复制构造函数</p>\r\n<p><code>begin()</code> 返回指向开头元素的迭代器</p>\r\n<p><code>end()</code>\r\n返回指向<strong>末尾的下一个元素</strong>的迭代器。</p>\r\n<p><code>size()</code> 返回容器的元素个数</p>\r\n<p><code>max_size()</code> 返回容器理论上能储存最大的元素个数</p>\r\n<p><code>empty()</code> 返回元素是否为空</p>\r\n<p><code>swap()</code> 交换两个容器</p>\r\n<p><code>clear()</code> 清空容器</p>\r\n<p><code>比较运算符</code> 按字典序比较两个元素的大小</p></li>\r\n</ul>\r\n<h2 id=\"序列式容器\">序列式容器</h2>\r\n<h3 id=\"vector\">vector</h3>\r\n<p><code>std::vector</code> 是STL提供的内存连续的，可变长度的数组。</p>\r\n<p>能提供线性复杂度的插入和删除，以及常数复杂度的随机访问</p>\r\n<h4 id=\"优点\">优点</h4>\r\n<ul>\r\n<li>可以动态分配内存</li>\r\n<li>重写了比较运算符和赋值运算符</li>\r\n<li>初始化简单，可以<code>&#123; &#125;</code>或者<code>=</code></li>\r\n</ul>\r\n<h4 id=\"初始化操作\">初始化操作</h4>\r\n<p><code>vector&lt;数据类型&gt; 变量名(初始空间，初始值)</code></p>\r\n<p>创建拷贝\r\n<code>vector&lt;数据类型&gt; 变量名(被拷贝的变量名)</code></p>\r\n<p>移动整个容器\r\n<code>vector&lt;数据类型&gt; 变量名(std::move(原容器))</code></p>\r\n<h4 id=\"成员函数\">成员函数</h4>\r\n<p><code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\r\n<p><code>front()</code> 返回首元素的引用</p>\r\n<p><code>back()</code> 返回末尾元素的引用</p>\r\n<p><code>data()</code> 返回数组第一个元素的指针</p>\r\n<p><code>resize()</code> 改变<code>vector</code>的长度，多退少补</p>\r\n<p><code>reserve()</code>\r\n使得<code>vector</code>预留一定内存空间，避免不必要的内存拷贝</p>\r\n<p><code>insert()</code> 支持在某个迭代器位置插入元素，线性复杂度</p>\r\n<p><code>erase()</code>\r\n删除某个迭代其或者区间的元素，返回最后被删除的迭代器</p>\r\n<p><code>push_back()</code> 在末尾插入一个元素</p>\r\n<p><code>pop_back()</code> 删除末尾元素</p>\r\n<p>### array</p>\r\n<p><code>std::array</code>是STL提供的内存连续、长度固定的数组数据结构,本质是对原生数组的直接封装</p>\r\n<p>#### 成员函数</p>\r\n<p><code>at(pos),operator[pos]</code> 返回下标为pos的元素</p>\r\n<p><code>front()</code> 返回首元素的引用</p>\r\n<p><code>back()</code> 返回末尾元素的引用</p>\r\n<p><code>data()</code> 返回数组第一个元素的指针</p>\r\n<p><code>fill(指定值)</code> 以指定值填充容器</p>\r\n<h3 id=\"deque\">deque</h3>\r\n<p><code>std::deque</code>是STL提供的双端队列数据结构</p>\r\n<h4 id=\"成员函数-1\">成员函数</h4>\r\n<p>同vector</p>\r\n<p><code>push_front()</code> 在头部插入一个元素</p>\r\n<p><code>pop_front()</code> 删除头部元素</p>\r\n<h3 id=\"list\">list</h3>\r\n<p><code>std::list</code> 是STL提供的一个双向链表数据结构</p>\r\n<h4 id=\"成员函数-2\">成员函数</h4>\r\n<p>同deque</p>\r\n<h2 id=\"关联式容器\">关联式容器</h2>\r\n<h3 id=\"set\">set</h3>\r\n<p><code>set</code>是关联容器，含有键值类型对象的已排序集</p>\r\n<p>内部通常采用红黑树实现</p>\r\n<h4 id=\"插入与删除操作\">插入与删除操作</h4>\r\n<p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到\r\nset 中。</p>\r\n<p><code>erase(x)</code> 删除值为 x 的 所有\r\n元素，返回删除元素的个数。</p>\r\n<p><code>erase(pos)</code> 删除迭代器为 pos\r\n的元素，要求迭代器必须合法。</p>\r\n<p><code>erase(first,last)</code> 删除迭代器在<span\r\nclass=\"math inline\">\\([First,last)\\)</span>范围内的所有元素。</p>\r\n<h4 id=\"迭代器\">迭代器</h4>\r\n<p><code>begin()</code> 返回指向首元素的迭代器，其中\r\n<code>*begin = front</code></p>\r\n<p><code>end()</code>\r\n返回指向数组尾端占位符的迭代器，注意是没有元素的。</p>\r\n<p><code>rbegin()</code>\r\n返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。</p>\r\n<p><code>rend()</code>\r\n返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。</p>\r\n<h4 id=\"查找操作\">查找操作</h4>\r\n<p><code>count(x)</code> 返回键值为x的元素数量</p>\r\n<p><code>find(x)</code> 存在键值为x的元素时会返回该元素的迭代器</p>\r\n<p><code>lower_bound(x)</code>\r\n返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回\r\n<code>end()</code></p>\r\n<p><code>upper_bound(x)</code>\r\n返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回<code>end()</code></p>\r\n<h3 id=\"map\">map</h3>\r\n<p><code>map</code>是有序键值对容器，它的元素的键是唯一的。<code>map</code>通常实现为红黑树</p>\r\n<p>搜索、移除和插入操作拥有对数复杂度</p>\r\n<p>map&lt;Key,T&gt; mp #### 操作</p>\r\n<p>查询操作同<code>set</code></p>\r\n<p>操作与删除操作同<code>set</code></p>\r\n<p>可以直接通过下标访问来进行查询或插入操作。例如\r\n<code>mp[\"Alan\"]=100</code></p>\r\n<p>通过向 map\r\n中插入一个类型为<code>pair&lt;Key, T&gt;</code>的值可以达到插入元素的目的，例如<code>mp.insert(pair&lt;string,int&gt;(\"Alan\",100))</code></p>\r\n<h2 id=\"容器适配器\">容器适配器</h2>\r\n<h3 id=\"栈\">栈</h3>\r\n<p><code>std::stack</code>是一种FILO的容器适配器</p>\r\n<h4 id=\"操作\">操作</h4>\r\n<p><code>top()</code> 访问栈顶元素</p>\r\n<p><code>pop()</code> 删除栈顶元素</p>\r\n<p><code>push(x)</code> 向栈顶插入x元素</p>\r\n<p><code>empty()</code> 询问容器是否为空</p>\r\n<p><code>size()</code> 查询容器中的元素数量</p>\r\n<h3 id=\"队列\">队列</h3>\r\n<p><code>std::queue</code>是一种FIFO的容器适配器</p>\r\n<h4 id=\"操作-1\">操作</h4>\r\n<p>同<code>stack</code></p>\r\n<p><code>front()</code> 访问队首元素</p>\r\n<h3 id=\"优先队列\">优先队列</h3>\r\n<p><code>std::priority_queue</code></p>\r\n<h4 id=\"操作-2\">操作</h4>\r\n<p>同<code>queue</code></p>\r\n<h2 id=\"其他非stl容器\">其他非STL容器</h2>\r\n<h3 id=\"bitset\">bitset</h3>\r\n<h3 id=\"string\">string</h3>\r\n<h3 id=\"pair\">pair</h3>\r\n<p><code>std::pair</code>\r\n是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。</p>\r\n<h4 id=\"操作-3\">操作</h4>\r\n<p>初始化</p>\r\n<p>可以在定义时直接完成<code>pair</code>的初始化</p>\r\n<p>也可以使用先定义，后赋值的方法完成<code>pair</code>的初始化</p>\r\n<p>还可以使用<code>std::make_pair</code>函数。</p>\r\n<p>该函数接受两个变量，并返回由这两个变量组成的<code>pair</code></p>\r\n<p>一种常用的方法是使用宏定义<code>#define mp make_pair</code>，将有些冗长的<code>make_pair</code>化简为<code>mp</code></p>\r\n<p><code>make_pair</code>可以配合<code>auto</code>使用，以避免显式声明数据类型</p>\r\n<p>访问</p>\r\n<p>通过成员函数<code>first</code>与<code>second</code>,可以访问<code>pair</code>中包含的两个变量</p>\r\n<p>比较</p>\r\n<p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>\r\n四个运算符会先比较两个<code>pair</code>中的第一个变量，在第一个变量相等的情况下再比较第二个变量</p>\r\n<h1 id=\"算法部分\">算法部分</h1>\r\n<h2 id=\"next_permutation\">next_permutation</h2>\r\n<p>通常用于生成序列的全排列</p>\r\n","text":"STL STL——OIWiki 共同点 声明形式： 容器名&lt;数据类型&gt; 变量名 迭代器：用来访问和检查STL容器中的元素的对象，与数据指针类似。主要支持自增（++）和解引用（*）运算符，其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。 用法：容器名&lt;数...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#stl\"><span class=\"toc-text\">STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">共同点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">序列式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vector\"><span class=\"toc-text\">vector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">初始化操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#deque\"><span class=\"toc-text\">deque</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">成员函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2\"><span class=\"toc-text\">成员函数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">关联式容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">插入与删除操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">查找操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">容器适配器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97\"><span class=\"toc-text\">优先队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-2\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%9D%9Estl%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">其他非STL容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bitset\"><span class=\"toc-text\">bitset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pair\"><span class=\"toc-text\">pair</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C-3\"><span class=\"toc-text\">操作</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86\"><span class=\"toc-text\">算法部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#next_permutation\"><span class=\"toc-text\">next_permutation</span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"机器学习基础","uid":"e9525b7ef8e5ead70d9f4aba30aa5c7e","slug":"机器学习基础","date":"2023-02-18T08:33:33.000Z","updated":"2023-02-18T09:53:49.795Z","comments":true,"path":"api/articles/机器学习基础.json","keywords":null,"cover":null,"text":"机器学习基础 DL 1.学习算法 机器学习算法是一种能够从数据中学习的算法，可定义为 ”对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习是指，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升\" 1.1 任务T 学习的过程本身并不是任务，学习是所谓获取...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"AI学习","slug":"AI学习","count":1,"path":"api/categories/AI学习.json"}],"tags":[{"name":"AI学习","slug":"AI学习","count":1,"path":"api/tags/AI学习.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}