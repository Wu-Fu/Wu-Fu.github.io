{"title":"图的存储","uid":"8fd51d91ee8f082030932013cc236c76","slug":"图的存储","date":"2022-01-16T08:23:46.000Z","updated":"2022-01-16T08:43:28.285Z","comments":true,"path":"api/articles/图的存储.json","keywords":null,"cover":null,"content":"<h1 id=\"图的存储\">图的存储</h1>\r\n<h2 id=\"直接存边\">直接存边</h2>\r\n<p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct edge&#123;\n    int n,w;\n&#125;\nvector&lt;edge&gt; e;\nvector&lt;bool&gt; vis\nvoid dfs(int u) &#123;\n    if (vis[u]) return;\n    vis[u] &#x3D; true;\n    for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) \n        if (e[i].u &#x3D;&#x3D; u)\n            dfs(e[i].v);\n&#125;</code></pre>\r\n<p>遍历效率低下，一般仅用于Kruskal算法</p>\r\n<h2 id=\"邻接矩阵\">邻接矩阵</h2>\r\n<p>使用一个二维数组<code>adj</code>来存边，其中<code>adj[u][v]</code>为1表示存在u到v的边，为0表示不存在</p>\r\n<p>如果是带边权的图，可以在 adj[u][v] 中存储</p>\r\n<p>一般只在稠密图中使用</p>\r\n<h2 id=\"邻接表\">邻接表</h2>\r\n<p>使用一个支持动态增加元素的数据结构构成的数组，如<code>vector&lt;int&gt; adj[n + 1]</code>来存边</p>\r\n<p>其中<code>adj[u]</code>存储的是点u的所有出边的相关信息（终点、边权等）</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;bool&gt; vis;\nvector&lt;vector&lt;int&gt; &gt; adj;\n\nbool find_edge(int u, int v) &#123;\n  for (int i &#x3D; 0; i &lt; adj[u].size(); ++i)\n    if (adj[u][i] &#x3D;&#x3D; v)\n      return true;\n  return false;\n&#125;\n\nvoid dfs(int u) &#123;\n  if (vis[u]) return;\n  vis[u] &#x3D; true;\n  for (int i &#x3D; 0; i &lt; adj[u].size(); ++i) \n    dfs(adj[u][i]);\n&#125;\n    adj[u].push_back(v);    &#x2F;&#x2F;插入边</code></pre>\r\n<p>存各种图都很合适，尤其适用于需要对一个点的所有出边进行排序的场合</p>\r\n<h2 id=\"前向星\">前向星</h2>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">struct node&#123;\n\tint x,y,w,next;\n&#125;a[500005];\n\nint len,last[15000]; &#x2F;&#x2F;len边的索引，last 点所连最后一条边的索引\n\nvoid ins(int x,int y,int w)&#123;\n\tlen++;\n\ta[len].x&#x3D;x;a[len].y&#x3D;y;a[len].w&#x3D;w;\n\ta[len].next&#x3D;last[x];last[x]&#x3D;len;\n&#125;\n\nfor(int i&#x3D;last[x];i;i&#x3D;a[i].next) &#x2F;&#x2F;遍历</code></pre>\r\n","text":"图的存储 直接存边 使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点 struct edge&#123; int n,w; &#125; vector&lt;edge&gt; e; vector&lt;bool&gt; vis void dfs(int u) &#12...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">图的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E8%BE%B9\"><span class=\"toc-text\">直接存边</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">邻接矩阵</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E8%A1%A8\"><span class=\"toc-text\">邻接表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%90%91%E6%98%9F\"><span class=\"toc-text\">前向星</span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"二分匹配","uid":"4aa58050e03a812b4fa7990ab0778c08","slug":"二分匹配","date":"2022-01-17T08:44:06.000Z","updated":"2022-01-18T04:49:57.042Z","comments":true,"path":"api/articles/二分匹配.json","keywords":null,"cover":null,"text":"二分匹配 bool dfs(int x) &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(mapp[x][i]&amp;&amp;(!used[i])) &#123; used[i]&#x3D;1; if(linker[i]...","link":"","photos":[],"count_time":{"symbolsCount":600,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"最短路","uid":"530e1936c4d6e837f2bf21a86f73c106","slug":"最短路","date":"2022-01-16T07:42:55.000Z","updated":"2022-01-17T07:53:02.872Z","comments":true,"path":"api/articles/最短路.json","keywords":null,"cover":null,"text":"最短路 性质 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边 对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过n，边数不会超过n-1 记号 n为图上点的数目，m为图上边的数目 s为最...","link":"","photos":[],"count_time":{"symbolsCount":226,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/02/20/pSXmfmj.jpg","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}