{"title":"图的存储","uid":"8fd51d91ee8f082030932013cc236c76","slug":"图的存储","date":"2022-01-16T08:23:46.000Z","updated":"2022-01-16T08:43:28.285Z","comments":true,"path":"api/articles/图的存储.json","keywords":null,"cover":null,"content":"<h1 id=\"图的存储\">图的存储</h1>\r\n<h2 id=\"直接存边\">直接存边</h2>\r\n<p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vector&lt;edge&gt; e;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; vis</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vis[u]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; ++i) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e[i].u == u)</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(e[i].v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>遍历效率低下，一般仅用于Kruskal算法</p>\r\n<h2 id=\"邻接矩阵\">邻接矩阵</h2>\r\n<p>使用一个二维数组<code>adj</code>来存边，其中<code>adj[u][v]</code>为1表示存在u到v的边，为0表示不存在</p>\r\n<p>如果是带边权的图，可以在 adj[u][v] 中存储</p>\r\n<p>一般只在稠密图中使用</p>\r\n<h2 id=\"邻接表\">邻接表</h2>\r\n<p>使用一个支持动态增加元素的数据结构构成的数组，如<code>vector&lt;int&gt; adj[n + 1]</code>来存边</p>\r\n<p>其中<code>adj[u]</code>存储的是点u的所有出边的相关信息（终点、边权等）</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">bool</span>&gt; vis;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; adj;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find_edge</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; adj[u].<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (adj[u][i] == v)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vis[u]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; adj[u].<span class=\"built_in\">size</span>(); ++i) </span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(adj[u][i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    adj[u].<span class=\"built_in\">push_back</span>(v);    <span class=\"comment\">//插入边</span></span><br></pre></td></tr></table></figure>\r\n<p>存各种图都很合适，尤其适用于需要对一个点的所有出边进行排序的场合</p>\r\n<h2 id=\"前向星\">前向星</h2>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w,next;</span><br><span class=\"line\">&#125;a[<span class=\"number\">500005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> len,last[<span class=\"number\">15000</span>]; <span class=\"comment\">//len边的索引，last 点所连最后一条边的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ins</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tlen++;</span><br><span class=\"line\">\ta[len].x=x;a[len].y=y;a[len].w=w;</span><br><span class=\"line\">\ta[len].next=last[x];last[x]=len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=last[x];i;i=a[i].next) <span class=\"comment\">//遍历</span></span><br></pre></td></tr></table></figure>\r\n","text":"图的存储 直接存边 使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点 123456789101112struct edge&#123; int n,w;&#125;vector&lt;edge&gt; e;vector&lt;bool&gt; visvoid dfs(...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">图的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E8%BE%B9\"><span class=\"toc-text\">直接存边</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">邻接矩阵</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%BB%E6%8E%A5%E8%A1%A8\"><span class=\"toc-text\">邻接表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%90%91%E6%98%9F\"><span class=\"toc-text\">前向星</span></a></li></ol></li></ol>","author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"二分匹配","uid":"4aa58050e03a812b4fa7990ab0778c08","slug":"二分匹配","date":"2022-01-17T08:44:06.000Z","updated":"2022-01-18T04:49:57.042Z","comments":true,"path":"api/articles/二分匹配.json","keywords":null,"cover":null,"text":"二分匹配 123456789101112131415161718192021222324252627bool dfs(int x)&#123; for(int i=1;i&lt;=n;i++) &#123; if(mapp[x][i]&amp;&amp;(!used[i])) &...","link":"","photos":[],"count_time":{"symbolsCount":574,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"最短路","uid":"530e1936c4d6e837f2bf21a86f73c106","slug":"最短路","date":"2022-01-16T07:42:55.000Z","updated":"2022-01-17T07:53:02.872Z","comments":true,"path":"api/articles/最短路.json","keywords":null,"cover":null,"text":"最短路 性质 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边 对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过n，边数不会超过n-1 记号 n为图上点的数目，m为图上边的数目 s为最...","link":"","photos":[],"count_time":{"symbolsCount":226,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":11,"path":"api/tags/算法.json"}],"author":{"name":"碔砆","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"BUPT AI专业大二学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}